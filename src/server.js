import { Http3Server } from '@fails-components/webtransport'
import { WebTransportSocketServer } from '@fails-components/webtransport-ponyfill-websocket'
import { generateWebTransportCertificate } from './certificate.js'
import { access, readFile, writeFile } from 'node:fs/promises'
import { watchFile } from 'node:fs'
import { AVSrouter } from './avsrouter.js'
import { createServer as createServerHttp1 } from 'http'
import { createServer as createServerHttps1 } from 'https'
import { pid } from 'node:process'
import { v4 as uuidv4 } from 'uuid'
import express from 'express'
import { DateTime } from 'luxon'

const mainfunc = async () => {
  console.log(`This process is pid ${pid}`)

  let certificate = null
  try {
    await access('./config/certificatecache.json')
    try {
      certificate = JSON.parse(
        await readFile('./config/certificatecache.json', {
          encoding: 'utf8',
          flag: 'r'
        })
      )
      if (certificate.validUntil - 24 * 60 * 60 * 1000 < Date.now()) {
        certificate = null // recreate, makes no sense to go online with a short lived cert
      }
    } catch (error) {
      console.log('error reading certifcate', error)
    }
  } catch (error) {
    // be silent if file does not exist
  }

  if (!certificate) {
    const attrs = [
      { shortName: 'C', value: 'DE' },
      { shortName: 'ST', value: 'Berlin' },
      { shortName: 'L', value: 'Berlin' },
      { shortName: 'O', value: 'FAILS avsrouter autogenerated certificate' },
      { shortName: 'CN', value: process.env.AVSROUTERHOST }
    ]
    certificate = await generateWebTransportCertificate(attrs, {
      days: 13
    })
    await writeFile(
      './config/certificatecache.json',
      JSON.stringify(certificate),
      (err) => {
        if (err) console.log('write certificate cache error', err)
      }
    )
  }

  {
    const zone = process.env.AVSTIMEZONE || 'Europe/Berlin'
    // ok, we got a certificate, we need to exit the process at the time when the certificate expires
    const endtime = DateTime.fromMillis(certificate.validUntil, { zone })
    // now get a random number from
    if (endtime < DateTime.local({ zone }).endOf('day')) {
      // really,  should not happen
      console.log(
        'Generated certifcate expires before the end of day, exit immediately!'
      )
      process.exit(0)
    }
    // now we get the start of the day before termination, add 60 + a random time between 0 and 180 minutes
    // thus the instances will restart between 1 and 4 in the night/morning
    const terminationtime = endtime
      .startOf('day')
      .plus({ minutes: 60 + Math.random() * 180 })
    if (terminationtime > endtime) terminationtime.minus({ days: 1 }) // after certificate expiration, so minus 1 day
    console.log(
      'Certificate will expire at ',
      endtime.toLocaleString(DateTime.DATETIME_FULL)
    )
    console.log(
      'Restart scheduled at ',
      terminationtime.toLocaleString(DateTime.DATETIME_FULL)
    )
    setInterval(() => {
      if (DateTime.now() > terminationtime) {
        console.log(
          'Restarting (terminating) since certificate, will expire soon at',
          endtime.toLocaleString(DateTime.DATETIME_FULL)
        )
        process.exit(0)
      }
    }, 1 * 60 * 1000)
  }

  let port = 8081
  if (process.env.AVSROUTERPORT) port = parseInt(process.env.AVSROUTERPORT, 10)

  const router = new AVSrouter({ spki: certificate.fingerprint, port })

  console.log('certificate hash ', certificate.fingerprint)
  console.log('start http/3 Server')
  let readyhttp3

  let http3serverv4
  // eslint-disable-next-line no-unused-vars
  let http3serverv6
  try {
    const secret = uuidv4()
    http3serverv4 = new Http3Server({
      port,
      host: process.env.AVSROUTERHOST,
      secret,
      cert: certificate.cert, // unclear if it is the correct format
      privKey: certificate.private,
      spki: certificate.fingerprint
    })
    /* http3serverv6 = new Http3Server({
    port,
    host: '::',
    secret, 
    cert: certificate.cert, // unclear if it is the correct format
    privKey: certificate.private
  }) */
    certificate = null
    router.runServerLoop(http3serverv4)
    // router.runServerLoop(http3serverv6)

    http3serverv4.startServer() // you can call destroy to remove the server
    console.log('http3 server started ipv4')
    readyhttp3 = true
    /* http3serverv6.startServer() // you can call destroy to remove the server
  console.log('server started ipv6') */
  } catch (error) {
    console.log('http3error', error)
  }
  let readyhttp1
  let readyacme

  try {
    console.log('start http/1 Server')
    let server
    let host = process.env.AVSROUTERHOST
    if (
      process.env.AVSROUTERURL &&
      process.env.AVSROUTERURL.startsWith('ws://')
    ) {
      // http1
      server = createServerHttp1()
      readyacme = true
      host = new URL(process.env.AVSROUTERURL).hostname
    } else {
      let options
      try {
        const key = await readFile(process.env.AVSROUTERKEYPEM, 'utf8')
        const cert = await readFile(process.env.AVSROUTERCERTPEM, 'utf8')
        options = {
          key,
          cert
        }
      } catch (error) {
        console.log('Problem reading ssl keys, load them later...', error)
      }

      // https1
      server = createServerHttps1(options)
      watchFile(
        process.env.AVSROUTERCERTPEM,
        { persistent: false },
        async (cur, prev) => {
          if (cur.mtime !== prev.mtime) {
            try {
              console.log('Reload certificates')
              const key = await readFile(process.env.AVSROUTERKEYPEM, 'utf8')
              const cert = await readFile(process.env.AVSROUTERCERTPEM, 'utf8')
              server.setSecureContext({ key, cert })
            } catch (error) {
              console.log('Problem renewing certificates: ', error)
            }
          }
        }
      )
      // server to answer challenges
      const app = express()

      // app.use(express.urlencoded({ extended: true }))
      // app.use(express.json())
      /*
      if (cfg.devmode) {
        app.use(cors())
      } */
      // Kubernetes livelyness and readyness probes
      app.get('/ready', (req, res) => {
        if (readyhttp3 && readyhttp1 && readyacme) return res.send('Ready')
        else res.status(500).send('Not ready')
      })
      app.get('/health', async (req, res) => {
        res.send('Healthy')
      })

      app.use(
        '/.well-known/acme-challenge',
        express.static(
          (process.env.AVSROUTERACMEHTTP1DIR
            ? process.env.AVSROUTERACMEHTTP1DIR
            : 'challenges') + '/.well-known/acme-challenge'
        )
      )

      app.listen(80, host, function () {
        console.log(
          'Failsserver acme challenge server running:',
          80,
          ' host:',
          host
        )
        readyacme = true
      })
    }
    const wtsserver = new WebTransportSocketServer({
      server,
      port
    })

    router.runServerLoop(wtsserver)
    wtsserver.startServer() // actually it is just listen....
    console.log('http1 server started ipv4')
    readyhttp1 = true
  } catch (error) {
    console.log('websocket error', error)
  }
}
mainfunc().catch((error) => {
  console.log('Unhandled error in mainfunc:', error)
})
