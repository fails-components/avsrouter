import { HttpServer } from '@fails-components/webtransport'
import { generateWebTransportCertificate } from './certificate.js'
import { access, readFile, writeFile } from 'node:fs/promises'
import { watchFile } from 'node:fs'
import { AVSrouter } from './avsrouter.js'
import { pid } from 'node:process'
import { v4 as uuidv4 } from 'uuid'
import express from 'express'
import { DateTime } from 'luxon'

const mainfunc = async () => {
  console.log(`This process is pid ${pid}`)

  let certificate = null
  try {
    await access('./config/certificatecache.json')
    try {
      certificate = JSON.parse(
        await readFile('./config/certificatecache.json', {
          encoding: 'utf8',
          flag: 'r'
        })
      )
      if (certificate.validUntil - 24 * 60 * 60 * 1000 < Date.now()) {
        certificate = null // recreate, makes no sense to go online with a short lived cert
      }
    } catch (error) {
      console.log('error reading certifcate', error)
    }
  } catch (error) {
    // be silent if file does not exist
  }

  if (!certificate) {
    const attrs = [
      { shortName: 'C', value: 'DE' },
      { shortName: 'ST', value: 'Berlin' },
      { shortName: 'L', value: 'Berlin' },
      { shortName: 'O', value: 'FAILS avsrouter autogenerated certificate' },
      { shortName: 'CN', value: process.env.AVSROUTERHOST }
    ]
    certificate = await generateWebTransportCertificate(attrs, {
      days: 13
    })
    await writeFile(
      './config/certificatecache.json',
      JSON.stringify(certificate),
      (err) => {
        if (err) console.log('write certificate cache error', err)
      }
    )
  }

  {
    const zone = process.env.AVSTIMEZONE || 'Europe/Berlin'
    // ok, we got a certificate, we need to exit the process at the time when the certificate expires
    const endtime = DateTime.fromMillis(certificate.validUntil, { zone })
    // now get a random number from
    if (endtime < DateTime.local({ zone }).endOf('day')) {
      // really,  should not happen
      console.log(
        'Generated certifcate expires before the end of day, exit immediately!'
      )
      process.exit(0)
    }
    // now we get the start of the day before termination, add 60 + a random time between 0 and 180 minutes
    // thus the instances will restart between 1 and 4 in the night/morning
    const terminationtime = endtime
      .startOf('day')
      .plus({ minutes: 60 + Math.random() * 180 })
    if (terminationtime > endtime) terminationtime.minus({ days: 1 }) // after certificate expiration, so minus 1 day
    console.log(
      'Certificate will expire at ',
      endtime.toLocaleString(DateTime.DATETIME_FULL)
    )
    console.log(
      'Restart scheduled at ',
      terminationtime.toLocaleString(DateTime.DATETIME_FULL)
    )
    setInterval(() => {
      if (DateTime.now() > terminationtime) {
        console.log(
          'Restarting (terminating) since certificate, will expire soon at',
          endtime.toLocaleString(DateTime.DATETIME_FULL)
        )
        process.exit(0)
      }
    }, 1 * 60 * 1000)
  }

  let port = 8081
  if (process.env.AVSROUTERPORT) port = parseInt(process.env.AVSROUTERPORT, 10)

  const router = new AVSrouter({ spki: certificate.fingerprint, port })

  console.log('certificate hash ', certificate.fingerprint)
  console.log('start http/3 Server')
  let readyhttp

  let httpserverv4
  // eslint-disable-next-line no-unused-vars
  let httpserverv6
  try {
    let certhttp2
    let privKeyhttp2
    if (process.env.AVSROUTERKEYPEM && process.env.AVSROUTERCERTPEM) {
      // use the same as the http/3 server in case the variables are not set
      try {
        privKeyhttp2 = await readFile(process.env.AVSROUTERKEYPEM, {
          encoding: 'utf8',
          flag: 'r'
        })
        certhttp2 = await readFile(process.env.AVSROUTERCERTPEM, {
          encoding: 'utf8',
          flag: 'r'
        })
      } catch (error) {
        console.log('Problem reading ssl keys, load them later...', error)
      }
    }

    const secret = uuidv4()
    httpserverv4 = new HttpServer({
      port,
      host: process.env.AVSROUTERHOST,
      secret,
      cert: certificate.cert, // unclear if it is the correct format
      privKey: certificate.private,
      spki: certificate.fingerprint,
      certhttp2,
      privKeyhttp2,
      reliability: 'both'
    })
    /* http3serverv6 = new Http3Server({
    port,
    host: '::',
    secret, 
    cert: certificate.cert, // unclear if it is the correct format
    privKey: certificate.private
  }) */
    certificate = null

    httpserverv4.startServer() // you can call destroy to remove the server
    console.log('combined http server started ipv4')
    readyhttp = true
    /* http3serverv6.startServer() // you can call destroy to remove the server
  console.log('server started ipv6') */

    router.runServerLoop(httpserverv4)
    // router.runServerLoop(http3serverv6)
  } catch (error) {
    console.log('http server error:', error)
  }
  let readyacme

  try {
    console.log('setup stuff for certificate updater')
    const host = process.env.AVSROUTERHOST

    watchFile(
      process.env.AVSROUTERCERTPEM,
      { persistent: false },
      async (cur, prev) => {
        if (cur.mtime !== prev.mtime) {
          try {
            console.log('Reload certificates')
            const key = await readFile(process.env.AVSROUTERKEYPEM, {
              encoding: 'utf8',
              flag: 'r'
            })
            const cert = await readFile(process.env.AVSROUTERCERTPEM, {
              encoding: 'utf8',
              flag: 'r'
            })
            httpserverv4.updateCert(cert, key, true /* http2only */)
          } catch (error) {
            console.log('Problem renewing certificates: ', error)
          }
        }
      }
    )
    // server to answer challenges
    const app = express()

    // app.use(express.urlencoded({ extended: true }))
    // app.use(express.json())
    /*
    if (cfg.devmode) {
      app.use(cors())
    } */
    // Kubernetes livelyness and readyness probes
    app.get('/ready', (req, res) => {
      if (readyhttp && readyacme) return res.send('Ready')
      else res.status(500).send('Not ready')
    })
    app.get('/health', async (req, res) => {
      res.send('Healthy')
    })

    app.use(
      '/.well-known/acme-challenge',
      express.static(
        (process.env.AVSROUTERACMEHTTP1DIR
          ? process.env.AVSROUTERACMEHTTP1DIR
          : 'challenges') + '/.well-known/acme-challenge'
      )
    )

    app.listen(80, host, function () {
      console.log(
        'Failsserver acme challenge server running:',
        80,
        ' host:',
        host
      )
      readyacme = true
    })
  } catch (error) {
    console.log('acme challenge error', error)
  }
}
mainfunc().catch((error) => {
  console.log('Unhandled error in mainfunc:', error)
})
